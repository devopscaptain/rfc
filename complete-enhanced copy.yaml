AWSTemplateFormatVersion: '2010-09-09'
Description: 'Complete Enhanced EC2 Compliance with S3 RFC Updates'

Parameters:
  NotificationEmail:
    Type: String
    Description: Email address for compliance notifications

Resources:
  RFCBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'rfc-docs-${AWS::AccountId}-${AWS::StackName}'
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true

  SNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub '${AWS::StackName}-alerts'
      Subscription:
        - Protocol: email
          Endpoint: !Ref NotificationEmail

  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CompliancePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:*
                  - cloudwatch:*
                  - s3:*
                  - sns:Publish
                  - bedrock:InvokeModel
                Resource: '*'

  SmartComplianceFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-compliance'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          RFC_BUCKET: !Ref RFCBucket
          SNS_TOPIC: !Ref SNSTopic
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          import time
          from datetime import datetime
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          ec2 = boto3.client('ec2')
          cloudwatch = boto3.client('cloudwatch')
          s3 = boto3.client('s3')
          sns = boto3.client('sns')
          bedrock = boto3.client('bedrock-runtime')
          
          def lambda_handler(event, context):
              try:
                  instance_id = event['detail']['instance-id']
                  state = event['detail']['state']
                  
                  if state != 'running':
                      return {'statusCode': 200, 'body': 'Ignored non-running state'}
                  
                  logger.info(f'Processing compliance for {instance_id}')
                  
                  response = ec2.describe_instances(InstanceIds=[instance_id])
                  instance = response['Reservations'][0]['Instances'][0]
                  
                  environment = get_environment_from_instance(instance)
                  
                  # Step 1: Send launch notification
                  send_launch_notification(instance_id, instance, environment)
                  time.sleep(5)
                  
                  # Get compliance rules and check
                  rules = get_compliance_rules_from_rfc(environment)
                  violations = check_compliance(instance, rules)
                  
                  if violations['missing_tags'] or violations['missing_alarms']:
                      # Step 2: Send RFC requirements notification
                      send_rfc_requirements_notification(instance_id, environment, violations, rules)
                      time.sleep(5)
                      
                      # Step 3: Auto-fix and send completion notification
                      actions = auto_fix_violations(instance_id, environment, violations)
                      time.sleep(5)
                      send_completion_notification(instance_id, environment, actions)
                  else:
                      send_already_compliant_notification(instance_id, environment)
                  
                  return {'statusCode': 200, 'body': 'Compliance check completed'}
                  
              except Exception as e:
                  logger.error(f'Error: {str(e)}')
                  return {'statusCode': 500, 'body': str(e)}
          
          def get_environment_from_instance(instance):
              name = ''
              for tag in instance.get('Tags', []):
                  if tag['Key'] == 'Name':
                      name = tag['Value'].lower()
                      break
              
              if any(env in name for env in ['dev', 'development']):
                  return 'development'
              elif any(env in name for env in ['prod', 'production']):
                  return 'production'
              elif any(env in name for env in ['test', 'staging']):
                  return 'testing'
              else:
                  return 'development'
          
          def get_instance_details(instance):
              details = {
                  'instance_type': instance.get('InstanceType', 'Unknown'),
                  'launch_time': instance.get('LaunchTime', datetime.now()).strftime('%Y-%m-%d %H:%M:%S UTC'),
                  'availability_zone': instance.get('Placement', {}).get('AvailabilityZone', 'Unknown'),
                  'vpc_id': instance.get('VpcId', 'Unknown'),
                  'subnet_id': instance.get('SubnetId', 'Unknown'),
                  'security_groups': [sg['GroupName'] for sg in instance.get('SecurityGroups', [])],
                  'current_tags': {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])}
              }
              return details
          
          def send_launch_notification(instance_id, instance, environment):
              details = get_instance_details(instance)
              
              subject = f'üöÄ NEW EC2 INSTANCE LAUNCHED - {environment.upper()} Environment'
              
              message = f"""üöÄ **NEW EC2 INSTANCE DETECTED & COMPLIANCE CHECK INITIATED**
          
          üîç **INSTANCE DETAILS:**
          ‚Ä¢ Instance ID: {instance_id}
          ‚Ä¢ Environment: {environment.upper()} üè∑Ô∏è
          ‚Ä¢ Instance Type: {details['instance_type']} üíª
          ‚Ä¢ Launch Time: {details['launch_time']} ‚è∞
          ‚Ä¢ Availability Zone: {details['availability_zone']} üåç
          ‚Ä¢ VPC ID: {details['vpc_id']} üîó
          ‚Ä¢ Subnet ID: {details['subnet_id']} üì°
          ‚Ä¢ Security Groups: {', '.join(details['security_groups'])} üîí
          
          üìã **CURRENT TAGS:**
          {chr(10).join([f'‚Ä¢ {k}: {v}' for k, v in details['current_tags'].items()])}
          
          üîÑ **STATUS:** Analyzing RFC compliance requirements...
          
          ‚è≥ Next: RFC compliance analysis in progress..."""
              
              sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=subject, Message=message)
              logger.info(f'Launch notification sent for {instance_id}')
          
          def get_compliance_rules_from_rfc(environment):
              try:
                  s3_objects = s3.list_objects_v2(Bucket=os.environ['RFC_BUCKET'])
                  if 'Contents' not in s3_objects:
                      return {'tags': [], 'alarms': []}
                  
                  md_files = [obj for obj in s3_objects['Contents'] if obj['Key'].endswith('.md')]
                  if not md_files:
                      return {'tags': [], 'alarms': []}
                  
                  latest_rfc = max(md_files, key=lambda x: x['LastModified'])
                  response = s3.get_object(Bucket=os.environ['RFC_BUCKET'], Key=latest_rfc['Key'])
                  rfc_content = response['Body'].read().decode('utf-8')
                  
                  prompt = f"""Extract compliance rules for {environment} environment from this RFC:
          
          {rfc_content}
          
          Return ONLY a JSON object: {{"tags": ["tag1", "tag2"], "alarms": ["CPUUtilization"]}}"""
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-haiku-20240307-v1:0',
                      body=json.dumps({
                          "messages": [{"role": "user", "content": prompt}],
                          "max_tokens": 1000,
                          "anthropic_version": "bedrock-2023-05-31"
                      })
                  )
                  
                  ai_response = json.loads(response['body'].read())['content'][0]['text']
                  rules = json.loads(ai_response)
                  logger.info(f'Claude extracted rules for {environment}: {rules}')
                  return rules
                  
              except Exception as e:
                  logger.error(f'Error extracting rules: {str(e)}')
                  return {'tags': [], 'alarms': []}
          
          def check_compliance(instance, rules):
              current_tags = {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])}
              required_tags = rules.get('tags', [])
              missing_tags = [tag for tag in required_tags if tag not in current_tags]
              return {'missing_tags': missing_tags, 'missing_alarms': rules.get('alarms', [])}
          
          def send_rfc_requirements_notification(instance_id, environment, violations, rules):
              subject = f'üìã RFC COMPLIANCE REQUIREMENTS - {environment.upper()} Environment'
              
              message = f"""üìã **RFC COMPLIANCE ANALYSIS COMPLETE**
          
          üéØ **INSTANCE:** {instance_id}
          üè∑Ô∏è **ENVIRONMENT:** {environment.upper()}
          
          üìÑ **RFC REQUIREMENTS FOR {environment.upper()} ENVIRONMENT:**
          
          üè∑Ô∏è **REQUIRED TAGS:**
          {chr(10).join([f'‚Ä¢ {tag} ‚úÖ' for tag in rules.get('tags', [])])}
          
          üìä **REQUIRED MONITORING:**
          {chr(10).join([f'‚Ä¢ {alarm} üìà' for alarm in rules.get('alarms', [])])}
          
          ‚ùå **MISSING COMPLIANCE ITEMS:**
          
          üè∑Ô∏è **Missing Tags ({len(violations['missing_tags'])}):**
          {chr(10).join([f'‚Ä¢ {tag} ‚ùå' for tag in violations['missing_tags']]) if violations['missing_tags'] else '‚Ä¢ All tags present ‚úÖ'}
          
          üìä **Missing Alarms ({len(violations['missing_alarms'])}):**
          {chr(10).join([f'‚Ä¢ {alarm} ‚ùå' for alarm in violations['missing_alarms']]) if violations['missing_alarms'] else '‚Ä¢ All alarms present ‚úÖ'}
          
          üîÑ **STATUS:** Auto-remediation starting in 5 seconds...
          
          ‚è≥ Next: Applying RFC compliance fixes..."""
              
              sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=subject, Message=message)
              logger.info(f'RFC requirements notification sent for {instance_id}')
          
          def auto_fix_violations(instance_id, environment, violations):
              actions = []
              
              if violations['missing_tags']:
                  tag_values = generate_tag_values_from_rfc(instance_id, environment, violations['missing_tags'])
                  
                  tags_to_add = []
                  for tag in violations['missing_tags']:
                      value = tag_values.get(tag, f'auto-{environment}')
                      tags_to_add.append({'Key': tag, 'Value': value})
                      actions.append(f'üè∑Ô∏è Added tag: {tag} = {value}')
                  
                  if tags_to_add:
                      ec2.create_tags(Resources=[instance_id], Tags=tags_to_add)
              
              if violations['missing_alarms']:
                  cloudwatch.put_metric_alarm(
                      AlarmName=f'{instance_id}-CPUUtilization',
                      ComparisonOperator='GreaterThanThreshold',
                      EvaluationPeriods=2,
                      MetricName='CPUUtilization',
                      Namespace='AWS/EC2',
                      Period=300,
                      Statistic='Average',
                      Threshold=80.0,
                      ActionsEnabled=True,
                      AlarmActions=[os.environ['SNS_TOPIC']],
                      AlarmDescription='CPU utilization alarm',
                      Dimensions=[{'Name': 'InstanceId', 'Value': instance_id}]
                  )
                  actions.append('üìä Created CPU monitoring alarm (>80% threshold)')
              
              return actions
          
          def generate_tag_values_from_rfc(instance_id, environment, missing_tags):
              try:
                  s3_objects = s3.list_objects_v2(Bucket=os.environ['RFC_BUCKET'])
                  rfc_content = ""
                  if 'Contents' in s3_objects:
                      md_files = [obj for obj in s3_objects['Contents'] if obj['Key'].endswith('.md')]
                      if md_files:
                          latest_rfc = max(md_files, key=lambda x: x['LastModified'])
                          response = s3.get_object(Bucket=os.environ['RFC_BUCKET'], Key=latest_rfc['Key'])
                          rfc_content = response['Body'].read().decode('utf-8')
                  
                  prompt = f"""Based on this RFC, generate tag values for {environment}:
          
          {rfc_content}
          
          Missing tags: {missing_tags}
          
          Return ONLY JSON: {{"tag1": "value1", "tag2": "value2"}}"""
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-haiku-20240307-v1:0',
                      body=json.dumps({
                          "messages": [{"role": "user", "content": prompt}],
                          "max_tokens": 1000,
                          "anthropic_version": "bedrock-2023-05-31"
                      })
                  )
                  
                  ai_response = json.loads(response['body'].read())['content'][0]['text']
                  tag_values = json.loads(ai_response)
                  logger.info(f'Claude generated tag values: {tag_values}')
                  return tag_values
                  
              except Exception as e:
                  logger.error(f'Error generating tag values: {str(e)}')
                  return {tag: f'auto-{environment}' for tag in missing_tags}
          
          def send_completion_notification(instance_id, environment, actions):
              subject = f'‚úÖ RFC COMPLIANCE COMPLETE - {environment.upper()} Environment'
              
              message = f"""‚úÖ **RFC COMPLIANCE SUCCESSFULLY APPLIED**
          
          üéØ **INSTANCE:** {instance_id}
          üè∑Ô∏è **ENVIRONMENT:** {environment.upper()}
          ‚è∞ **COMPLETION TIME:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
          
          üîß **ACTIONS COMPLETED ({len(actions)}):**
          {chr(10).join([f'‚Ä¢ {action}' for action in actions])}
          
          üéâ **COMPLIANCE STATUS:** FULLY COMPLIANT ‚úÖ
          
          üìä **SUMMARY:**
          ‚Ä¢ Instance is now RFC compliant
          ‚Ä¢ All required tags applied
          ‚Ä¢ Monitoring alarms configured
          ‚Ä¢ Ready for production use
          
          üîî **MONITORING:** You will receive alerts if compliance drifts
          
          Thank you for using Smart RFC Compliance! üöÄ"""
              
              sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=subject, Message=message)
              logger.info(f'Completion notification sent for {instance_id}')
          
          def send_already_compliant_notification(instance_id, environment):
              subject = f'‚úÖ ALREADY RFC COMPLIANT - {environment.upper()} Environment'
              
              message = f"""‚úÖ **INSTANCE ALREADY RFC COMPLIANT**
          
          üéØ **INSTANCE:** {instance_id}
          üè∑Ô∏è **ENVIRONMENT:** {environment.upper()}
          ‚è∞ **CHECK TIME:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
          
          üéâ **GREAT NEWS!** This instance already meets all RFC requirements:
          ‚Ä¢ All required tags present ‚úÖ
          ‚Ä¢ Monitoring alarms configured ‚úÖ
          ‚Ä¢ No action needed ‚úÖ
          
          üìä **STATUS:** FULLY COMPLIANT
          
          Keep up the excellent work! üåü"""
              
              sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=subject, Message=message)
              logger.info(f'Already compliant notification sent for {instance_id}')

  RFCUpdateScannerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-rfc-scanner'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Timeout: 900
      Environment:
        Variables:
          RFC_BUCKET: !Ref RFCBucket
          SNS_TOPIC: !Ref SNSTopic
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          import time
          from datetime import datetime
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          ec2 = boto3.client('ec2')
          cloudwatch = boto3.client('cloudwatch')
          s3 = boto3.client('s3')
          sns = boto3.client('sns')
          bedrock = boto3.client('bedrock-runtime')
          
          def lambda_handler(event, context):
              try:
                  logger.info('RFC document updated - scanning existing instances')
                  
                  # Send RFC update notification
                  send_rfc_update_notification()
                  time.sleep(5)
                  
                  # Get all running instances
                  instances = get_all_running_instances()
                  logger.info(f'Found {len(instances)} running instances to check')
                  
                  updated_instances = []
                  
                  for instance in instances:
                      instance_id = instance['InstanceId']
                      environment = get_environment_from_instance(instance)
                      
                      # Get latest RFC rules
                      rules = get_compliance_rules_from_rfc(environment)
                      violations = check_compliance(instance, rules)
                      
                      if violations['missing_tags'] or violations['missing_alarms']:
                          actions = auto_fix_violations(instance_id, environment, violations)
                          updated_instances.append({
                              'instance_id': instance_id,
                              'environment': environment,
                              'actions': actions
                          })
                          time.sleep(2)  # Small delay between instances
                  
                  # Send summary notification
                  send_update_summary_notification(updated_instances)
                  
                  return {'statusCode': 200, 'body': f'Updated {len(updated_instances)} instances'}
                  
              except Exception as e:
                  logger.error(f'Error: {str(e)}')
                  return {'statusCode': 500, 'body': str(e)}
          
          def get_all_running_instances():
              response = ec2.describe_instances(
                  Filters=[{'Name': 'instance-state-name', 'Values': ['running']}]
              )
              instances = []
              for reservation in response['Reservations']:
                  instances.extend(reservation['Instances'])
              return instances
          
          def get_environment_from_instance(instance):
              name = ''
              for tag in instance.get('Tags', []):
                  if tag['Key'] == 'Name':
                      name = tag['Value'].lower()
                      break
              
              if any(env in name for env in ['dev', 'development']):
                  return 'development'
              elif any(env in name for env in ['prod', 'production']):
                  return 'production'
              elif any(env in name for env in ['test', 'staging']):
                  return 'testing'
              else:
                  return 'development'
          
          def get_compliance_rules_from_rfc(environment):
              try:
                  s3_objects = s3.list_objects_v2(Bucket=os.environ['RFC_BUCKET'])
                  if 'Contents' not in s3_objects:
                      return {'tags': [], 'alarms': []}
                  
                  md_files = [obj for obj in s3_objects['Contents'] if obj['Key'].endswith('.md')]
                  if not md_files:
                      return {'tags': [], 'alarms': []}
                  
                  latest_rfc = max(md_files, key=lambda x: x['LastModified'])
                  response = s3.get_object(Bucket=os.environ['RFC_BUCKET'], Key=latest_rfc['Key'])
                  rfc_content = response['Body'].read().decode('utf-8')
                  
                  prompt = f"""Extract compliance rules for {environment} environment from this RFC:
          
          {rfc_content}
          
          Return ONLY a JSON object: {{"tags": ["tag1", "tag2"], "alarms": ["CPUUtilization"]}}"""
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-haiku-20240307-v1:0',
                      body=json.dumps({
                          "messages": [{"role": "user", "content": prompt}],
                          "max_tokens": 1000,
                          "anthropic_version": "bedrock-2023-05-31"
                      })
                  )
                  
                  ai_response = json.loads(response['body'].read())['content'][0]['text']
                  rules = json.loads(ai_response)
                  return rules
                  
              except Exception as e:
                  logger.error(f'Error extracting rules: {str(e)}')
                  return {'tags': [], 'alarms': []}
          
          def check_compliance(instance, rules):
              current_tags = {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])}
              required_tags = rules.get('tags', [])
              missing_tags = [tag for tag in required_tags if tag not in current_tags]
              return {'missing_tags': missing_tags, 'missing_alarms': rules.get('alarms', [])}
          
          def auto_fix_violations(instance_id, environment, violations):
              actions = []
              
              if violations['missing_tags']:
                  tag_values = generate_tag_values_from_rfc(instance_id, environment, violations['missing_tags'])
                  
                  tags_to_add = []
                  for tag in violations['missing_tags']:
                      value = tag_values.get(tag, f'auto-{environment}')
                      tags_to_add.append({'Key': tag, 'Value': value})
                      actions.append(f'üè∑Ô∏è Added tag: {tag} = {value}')
                  
                  if tags_to_add:
                      ec2.create_tags(Resources=[instance_id], Tags=tags_to_add)
              
              if violations['missing_alarms']:
                  cloudwatch.put_metric_alarm(
                      AlarmName=f'{instance_id}-CPUUtilization',
                      ComparisonOperator='GreaterThanThreshold',
                      EvaluationPeriods=2,
                      MetricName='CPUUtilization',
                      Namespace='AWS/EC2',
                      Period=300,
                      Statistic='Average',
                      Threshold=80.0,
                      ActionsEnabled=True,
                      AlarmActions=[os.environ['SNS_TOPIC']],
                      AlarmDescription='CPU utilization alarm',
                      Dimensions=[{'Name': 'InstanceId', 'Value': instance_id}]
                  )
                  actions.append('üìä Created CPU monitoring alarm')
              
              return actions
          
          def generate_tag_values_from_rfc(instance_id, environment, missing_tags):
              try:
                  s3_objects = s3.list_objects_v2(Bucket=os.environ['RFC_BUCKET'])
                  rfc_content = ""
                  if 'Contents' in s3_objects:
                      md_files = [obj for obj in s3_objects['Contents'] if obj['Key'].endswith('.md')]
                      if md_files:
                          latest_rfc = max(md_files, key=lambda x: x['LastModified'])
                          response = s3.get_object(Bucket=os.environ['RFC_BUCKET'], Key=latest_rfc['Key'])
                          rfc_content = response['Body'].read().decode('utf-8')
                  
                  prompt = f"""Based on this RFC, generate tag values for {environment}:
          
          {rfc_content}
          
          Missing tags: {missing_tags}
          
          Return ONLY JSON: {{"tag1": "value1", "tag2": "value2"}}"""
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-haiku-20240307-v1:0',
                      body=json.dumps({
                          "messages": [{"role": "user", "content": prompt}],
                          "max_tokens": 1000,
                          "anthropic_version": "bedrock-2023-05-31"
                      })
                  )
                  
                  ai_response = json.loads(response['body'].read())['content'][0]['text']
                  tag_values = json.loads(ai_response)
                  return tag_values
                  
              except Exception as e:
                  logger.error(f'Error generating tag values: {str(e)}')
                  return {tag: f'auto-{environment}' for tag in missing_tags}
          
          def send_rfc_update_notification():
              subject = 'üìÑ RFC DOCUMENT UPDATED - Scanning Existing Instances'
              
              message = f"""üìÑ **RFC COMPLIANCE DOCUMENT UPDATED**
          
          üîÑ **STATUS:** RFC document changes detected in S3
          ‚è∞ **TIME:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
          
          üîç **ACTION:** Scanning all existing EC2 instances for compliance
          
          üìä **PROCESS:**
          ‚Ä¢ Reading updated RFC requirements
          ‚Ä¢ Checking all running instances
          ‚Ä¢ Applying new compliance rules
          ‚Ä¢ Updating tags and monitoring
          
          ‚è≥ **ESTIMATED TIME:** 2-5 minutes depending on instance count
          
          üìß **NEXT:** You'll receive a summary of all updates applied"""
              
              sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=subject, Message=message)
          
          def send_update_summary_notification(updated_instances):
              subject = f'‚úÖ RFC UPDATE COMPLETE - {len(updated_instances)} Instances Updated'
              
              if not updated_instances:
                  message = """‚úÖ **RFC UPDATE SCAN COMPLETE**
          
          üéâ **GREAT NEWS!** All existing instances are already compliant with the updated RFC.
          
          üìä **SUMMARY:**
          ‚Ä¢ No instances required updates
          ‚Ä¢ All systems remain compliant
          ‚Ä¢ No action needed
          
          üåü **STATUS:** All instances RFC compliant ‚úÖ"""
              else:
                  instance_details = []
                  for inst in updated_instances:
                      actions_text = chr(10).join([f'    ‚Ä¢ {action}' for action in inst['actions']])
                      instance_details.append(f"""
          üéØ **{inst['instance_id']}** ({inst['environment'].upper()})
          {actions_text}""")
                  
                  message = f"""‚úÖ **RFC UPDATE SCAN COMPLETE**
          
          üìä **SUMMARY:** Updated {len(updated_instances)} instances with new RFC requirements
          ‚è∞ **COMPLETION TIME:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
          
          üîß **UPDATED INSTANCES:**
          {chr(10).join(instance_details)}
          
          üéâ **STATUS:** All instances now RFC compliant ‚úÖ
          
          üìà **MONITORING:** All instances have updated monitoring and tags"""
              
              sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=subject, Message=message)

  EC2EventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Trigger compliance on EC2 events'
      EventPattern:
        source: ['aws.ec2']
        detail-type: ['EC2 Instance State-change Notification']
        detail:
          state: ['running']
      State: ENABLED
      Targets:
        - Arn: !GetAtt SmartComplianceFunction.Arn
          Id: SmartComplianceTarget

  S3EventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Trigger RFC scanner when S3 object is created/updated'
      EventPattern:
        source: ['aws.s3']
        detail-type: ['Object Created']
        detail:
          bucket:
            name: [!Ref RFCBucket]
          object:
            key: [{"suffix": ".md"}]
      State: ENABLED
      Targets:
        - Arn: !GetAtt RFCUpdateScannerFunction.Arn
          Id: RFCScannerTarget

  SmartCompliancePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SmartComplianceFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EC2EventRule.Arn

  RFCScannerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RFCUpdateScannerFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt S3EventRule.Arn

Outputs:
  RFCBucket:
    Description: 'S3 bucket for RFC documents'
    Value: !Ref RFCBucket
